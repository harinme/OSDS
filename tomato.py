'''
n행 m열
1: 익은 토마토
0: 안 익은 토마토
-1: 빈 칸

최소 일수 구하기 ---> bfs..
bfs가 인접 노드를 모두 방문하고 그 다음 깊이 방문하니까 + 최단거리

안 익은 토마토 0이 하나라도 있으면 -1
모든 칸이 1 혹은 -1이 되면 계산!!

익은 토마토가 상하좌우로 익힘을 전달..
'''
# [1] 익은 토마토 좌표 담기 : 토마토가 익는 날을 기록
# [2] 큐에서 좌표를 꺼내서 상하좌우 검사
# [3] 검사해서 0이 있으면 -> 현재칸 +1을 새 값으로 저장 (익는데까지 걸린 일 수)
# [4] 큐가 빌 때까지 반복 
# [5] 마지막에 0이 남으면 -1, 남은 최대값에서 1을 빼면 토마토가 다 익을 때까지 걸린 수



from collections import deque

M, N = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(N)]

# 익은 토마토 좌표를 큐에 넣기
queue = deque()

for i in range(N):
    for j in range(M):
        if arr[i][j] == 1:  # 익은 토마토면
            queue.append((i, j))    # 큐에 넣는다 
            
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

while queue:
    r, c = queue.popleft()  # 익은 좌표 꺼내기
    for d in range(4):
        nr, nc = r + dr[d], c + dc[d]

        # 범위 만족하면서, 해당 익은 토마토 상하좌우에 안 익은 토마토가 있다면
        if 0 <= nr < N and 0 <= nc < M and arr[nr][nc] == 0:
            arr[nr][nc] = arr[r][c] + 1     # 안 익은 토마토가 익는 날짜는 익은 토마토 날짜 + 1
            queue.append((nr, nc))  # 익었으니까 좌표 담기 

ans = 0
for row in arr:
    if 0 in row:    # 만약 arr에 안 익은 토마토가 남아있으면
        print(-1)
        exit()  # 이거 해줘야함.. 근데 코테에서 이거 못 쓰게 한다는 소리가,,??
    ans = max(ans, max(row))    # 0 없으면 최대값 구하기 = 토마토가 다 익을 때까지 걸린 수
print(ans - 1)


#==========다른 방식 즉., Gpt..
'''
하루에 한 칸씩 상하좌우로 전파된다 
-> 토마토가 익을 때까지 걸린 일수는
-> 가장 가까운 익은 토마토로부터 몇 칸을 거쳐왔느냐!

한 걸음 당 하루
시작점(익은 토마토 위치)에서 목적지(안 익은 토마토 위치)까지 최소 칸 수를 찾으면 
그만큼 하루가 지난 것과 같음

--> 그래서 DP 방식으로 각 칸을 익은 토마토까지의 최단거리로 채워넣기 
----> 최댓값이 모든 토마토가 다 익는데 필요한 최소 일수가 된다
'''
